/**\n * Tests et validation de la migration vers le modèle Operation unifié\n * \n * Ce fichier contient les tests de validation pour s'assurer que :\n * 1. La migration des données existantes fonctionne correctement\n * 2. Les calculs TVA/URSSAF donnent les mêmes résultats\n * 3. Aucune donnée n'est perdue pendant la migration\n */\n\nimport type { Invoice, Expense, Operation, VatCalculation, UrssafCalculation } from '../types'\nimport { \n  invoiceToOperation, \n  expenseToOperation, \n  migratePeriodToOperations,\n  calculateOperationAmounts,\n  validateOperation\n} from './operationMigration'\nimport { \n  calculateVatForOperations, \n  calculateUrssafForOperations,\n  compareWithLegacyCalculation\n} from './operationVatCalculations'\n\n// =============================================================================\n// DONNÉES DE TEST\n// =============================================================================\n\n// Exemple de facture (ancienne modèle)\nconst sampleInvoice: Invoice = {\n  id: 'inv-001',\n  number: 'F2025-001',\n  client: 'Entreprise ABC',\n  description: 'Développement site web',\n  amount_ht_cents: 500000, // 5000€\n  tva_rate: 20,\n  amount_ttc_cents: 600000, // 6000€\n  issued_date: '2025-08-01',\n  payment_date: '2025-08-15',\n  due_date: '2025-08-31',\n  status: 'paid',\n  is_service: true, // Prestation -> TVA sur encaissement\n  delivery_date: undefined,\n  created_at: '2025-08-01T10:00:00Z'\n}\n\n// Exemple de dépense (ancien modèle)\nconst sampleExpense: Expense = {\n  id: 'exp-001',\n  label: 'Achat ordinateur portable',\n  category: 'Matériel',\n  amount_ht_cents: 150000, // 1500€\n  tva_rate: 20,\n  amount_ttc_cents: 180000, // 1800€\n  expense_date: '2025-08-05',\n  payment_date: '2025-08-05',\n  supplier: 'Magasin Informatique',\n  receipt_path: '/documents/facture-ordinateur.pdf',\n  is_deductible: true,\n  is_service: false,\n  created_at: '2025-08-05T14:30:00Z'\n}\n\n// =============================================================================\n// TESTS DE MIGRATION\n// =============================================================================\n\n/**\n * Teste la conversion d'une facture vers une opération\n */\nexport function testInvoiceToOperation(): { success: boolean; message: string } {\n  try {\n    const operation = invoiceToOperation(sampleInvoice)\n    \n    // Vérifications\n    const checks = [\n      { test: operation.sens === 'vente', message: 'Sens doit être \"vente\"' },\n      { test: operation.amount_ht_cents === sampleInvoice.amount_ht_cents, message: 'Montant HT conservé' },\n      { test: operation.amount_ttc_cents === sampleInvoice.amount_ttc_cents, message: 'Montant TTC conservé' },\n      { test: operation.tva_rate === sampleInvoice.tva_rate, message: 'Taux TVA conservé' },\n      { test: operation.client_supplier === sampleInvoice.client, message: 'Client conservé' },\n      { test: operation.tva_sur_encaissements === sampleInvoice.is_service, message: 'TVA sur encaissements mappée' },\n      { test: operation.encaissement_date === sampleInvoice.payment_date, message: 'Date encaissement mappée' },\n      { test: operation.reference === sampleInvoice.number, message: 'Référence mappée' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Migration facture → opération réussie' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur migration facture: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste la conversion d'une dépense vers une opération\n */\nexport function testExpenseToOperation(): { success: boolean; message: string } {\n  try {\n    const operation = expenseToOperation(sampleExpense)\n    \n    // Vérifications\n    const checks = [\n      { test: operation.sens === 'achat', message: 'Sens doit être \"achat\"' },\n      { test: operation.amount_ht_cents === sampleExpense.amount_ht_cents, message: 'Montant HT conservé' },\n      { test: operation.amount_ttc_cents === sampleExpense.amount_ttc_cents, message: 'Montant TTC conservé' },\n      { test: operation.tva_rate === sampleExpense.tva_rate, message: 'Taux TVA conservé' },\n      { test: operation.client_supplier === sampleExpense.supplier, message: 'Fournisseur conservé' },\n      { test: operation.category === sampleExpense.category, message: 'Catégorie conservée' },\n      { test: operation.tva_sur_encaissements === false, message: 'TVA achats toujours à la facturation' },\n      { test: operation.status === 'paid', message: 'Dépenses considérées comme payées' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Migration dépense → opération réussie' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur migration dépense: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste la migration complète d'une période\n */\nexport function testPeriodMigration(): { success: boolean; message: string } {\n  try {\n    const invoices = [sampleInvoice]\n    const expenses = [sampleExpense]\n    \n    const operations = migratePeriodToOperations(invoices, expenses)\n    \n    // Vérifications\n    const checks = [\n      { test: operations.length === 2, message: 'Nombre total d\\'opérations correct' },\n      { test: operations.filter(op => op.sens === 'vente').length === 1, message: 'Une vente migrée' },\n      { test: operations.filter(op => op.sens === 'achat').length === 1, message: 'Un achat migré' },\n      { test: operations.every(op => op.id && op.created_at), message: 'Toutes les opérations ont un ID et date création' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Migration période complète réussie' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur migration période: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n// =============================================================================\n// TESTS DE CALCUL\n// =============================================================================\n\n/**\n * Teste les calculs automatiques de montants\n */\nexport function testCalculateAmounts(): { success: boolean; message: string } {\n  try {\n    const amountHt = 100000 // 1000€\n    const tvaRate = 20 // 20%\n    \n    const result = calculateOperationAmounts(amountHt, tvaRate)\n    \n    const expectedTva = 20000 // 200€\n    const expectedTtc = 120000 // 1200€\n    \n    const checks = [\n      { test: result.amount_ht_cents === amountHt, message: 'HT conservé' },\n      { test: result.tva_cents === expectedTva, message: 'TVA calculée correctement' },\n      { test: result.amount_ttc_cents === expectedTtc, message: 'TTC calculé correctement' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Calculs automatiques corrects' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs calculs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur calculs: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste la validation d'opération\n */\nexport function testValidateOperation(): { success: boolean; message: string } {\n  try {\n    // Opération valide\n    const validOperation: Partial<Operation> = {\n      label: 'Test opération',\n      sens: 'vente',\n      amount_ht_cents: 100000,\n      tva_rate: 20,\n      date: '2025-08-01'\n    }\n    \n    const validErrors = validateOperation(validOperation)\n    \n    // Opération invalide\n    const invalidOperation: Partial<Operation> = {\n      label: '', // Manquant\n      sens: 'vente',\n      amount_ht_cents: -1000, // Négatif\n      tva_rate: 50, // Trop élevé\n      date: '2025-08-01',\n      tva_sur_encaissements: true // Mais pas de date d'encaissement\n    }\n    \n    const invalidErrors = validateOperation(invalidOperation)\n    \n    const checks = [\n      { test: validErrors.length === 0, message: 'Opération valide ne génère pas d\\'erreurs' },\n      { test: invalidErrors.length > 0, message: 'Opération invalide génère des erreurs' },\n      { test: invalidErrors.some(e => e.includes('libellé')), message: 'Détecte libellé manquant' },\n      { test: invalidErrors.some(e => e.includes('montant')), message: 'Détecte montant invalide' },\n      { test: invalidErrors.some(e => e.includes('TVA')), message: 'Détecte taux TVA invalide' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Validation d\\'opération fonctionne' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs validation: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur validation: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n// =============================================================================\n// TESTS DE CALCUL TVA\n// =============================================================================\n\n/**\n * Teste les nouveaux calculs TVA\n */\nexport function testVatCalculations(): { success: boolean; message: string } {\n  try {\n    const operations = migratePeriodToOperations([sampleInvoice], [sampleExpense])\n    const period = '2025-08'\n    \n    const vatCalc = calculateVatForOperations(period, operations)\n    \n    // Vérifications attendues :\n    // - TVA collectée : 100000 centimes (1000€) car la facture a été encaissée en août\n    // - TVA déductible : 30000 centimes (300€) car la dépense a été faite en août\n    // - TVA due : 70000 centimes (700€)\n    \n    const checks = [\n      { test: vatCalc.period === period, message: 'Période correcte' },\n      { test: vatCalc.collected_vat_cents === 100000, message: 'TVA collectée calculée' },\n      { test: vatCalc.deductible_vat_cents === 30000, message: 'TVA déductible calculée' },\n      { test: vatCalc.vat_due_cents === 70000, message: 'TVA due calculée' },\n      { test: vatCalc.operations_breakdown.length === 2, message: 'Breakdown des opérations' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Calculs TVA nouveaux corrects' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs TVA: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur calculs TVA: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste les calculs URSSAF\n */\nexport function testUrssafCalculations(): { success: boolean; message: string } {\n  try {\n    const operations = migratePeriodToOperations([sampleInvoice], [sampleExpense])\n    const period = '2025-08'\n    const urssafRate = 22 // 22%\n    \n    const urssafCalc = calculateUrssafForOperations(period, operations, urssafRate)\n    \n    // Vérifications attendues :\n    // - Revenu HT : 500000 centimes (5000€) - uniquement les ventes\n    // - URSSAF due : 110000 centimes (1100€) = 5000€ * 22%\n    \n    const checks = [\n      { test: urssafCalc.period === period, message: 'Période correcte' },\n      { test: urssafCalc.revenue_ht_cents === 500000, message: 'Revenu HT calculé' },\n      { test: urssafCalc.urssaf_due_cents === 110000, message: 'URSSAF due calculée' },\n      { test: urssafCalc.urssaf_rate === urssafRate, message: 'Taux URSSAF correct' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Calculs URSSAF nouveaux corrects' }\n    } else {\n      return { \n        success: false, \n        message: `Échecs URSSAF: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur calculs URSSAF: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n// =============================================================================\n// SUITE DE TESTS COMPLÈTE\n// =============================================================================\n\n/**\n * Exécute tous les tests de migration\n */\nexport function runAllMigrationTests(): {\n  success: boolean\n  results: Array<{ test: string; success: boolean; message: string }>\n  summary: string\n} {\n  const tests = [\n    { name: 'Migration Facture → Opération', test: testInvoiceToOperation },\n    { name: 'Migration Dépense → Opération', test: testExpenseToOperation },\n    { name: 'Migration Période Complète', test: testPeriodMigration },\n    { name: 'Calculs Automatiques', test: testCalculateAmounts },\n    { name: 'Validation Opération', test: testValidateOperation },\n    { name: 'Nouveaux Calculs TVA', test: testVatCalculations },\n    { name: 'Nouveaux Calculs URSSAF', test: testUrssafCalculations }\n  ]\n  \n  const results = tests.map(({ name, test }) => ({\n    test: name,\n    ...test()\n  }))\n  \n  const successCount = results.filter(r => r.success).length\n  const totalCount = results.length\n  const overallSuccess = successCount === totalCount\n  \n  const summary = `Tests Migration: ${successCount}/${totalCount} réussis. ${overallSuccess ? '✅ SUCCÈS' : '❌ ÉCHECS'}`\n  \n  return {\n    success: overallSuccess,\n    results,\n    summary\n  }\n}\n\n/**\n * Utilitaire pour logger les résultats des tests\n */\nexport function logTestResults(): void {\n  console.log('🧪 === TESTS MIGRATION MODÈLE OPERATION UNIFIÉ ===')\n  \n  const { success, results, summary } = runAllMigrationTests()\n  \n  console.log(`\\n📊 ${summary}\\n`)\n  \n  results.forEach(result => {\n    const icon = result.success ? '✅' : '❌'\n    console.log(`${icon} ${result.test}: ${result.message}`)\n  })\n  \n  if (success) {\n    console.log('\\n🎉 Tous les tests passent ! La migration est prête.')\n  } else {\n    console.log('\\n⚠️  Certains tests échouent. Vérifier avant déploiement.')\n  }\n  \n  console.log('\\n=== FIN TESTS ===')\n}