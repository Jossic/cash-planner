/**\n * Tests et validation de la migration vers le mod√®le Operation unifi√©\n * \n * Ce fichier contient les tests de validation pour s'assurer que :\n * 1. La migration des donn√©es existantes fonctionne correctement\n * 2. Les calculs TVA/URSSAF donnent les m√™mes r√©sultats\n * 3. Aucune donn√©e n'est perdue pendant la migration\n */\n\nimport type { Invoice, Expense, Operation, VatCalculation, UrssafCalculation } from '../types'\nimport { \n  invoiceToOperation, \n  expenseToOperation, \n  migratePeriodToOperations,\n  calculateOperationAmounts,\n  validateOperation\n} from './operationMigration'\nimport { \n  calculateVatForOperations, \n  calculateUrssafForOperations,\n  compareWithLegacyCalculation\n} from './operationVatCalculations'\n\n// =============================================================================\n// DONN√âES DE TEST\n// =============================================================================\n\n// Exemple de facture (ancienne mod√®le)\nconst sampleInvoice: Invoice = {\n  id: 'inv-001',\n  number: 'F2025-001',\n  client: 'Entreprise ABC',\n  description: 'D√©veloppement site web',\n  amount_ht_cents: 500000, // 5000‚Ç¨\n  tva_rate: 20,\n  amount_ttc_cents: 600000, // 6000‚Ç¨\n  issued_date: '2025-08-01',\n  payment_date: '2025-08-15',\n  due_date: '2025-08-31',\n  status: 'paid',\n  is_service: true, // Prestation -> TVA sur encaissement\n  delivery_date: undefined,\n  created_at: '2025-08-01T10:00:00Z'\n}\n\n// Exemple de d√©pense (ancien mod√®le)\nconst sampleExpense: Expense = {\n  id: 'exp-001',\n  label: 'Achat ordinateur portable',\n  category: 'Mat√©riel',\n  amount_ht_cents: 150000, // 1500‚Ç¨\n  tva_rate: 20,\n  amount_ttc_cents: 180000, // 1800‚Ç¨\n  expense_date: '2025-08-05',\n  payment_date: '2025-08-05',\n  supplier: 'Magasin Informatique',\n  receipt_path: '/documents/facture-ordinateur.pdf',\n  is_deductible: true,\n  is_service: false,\n  created_at: '2025-08-05T14:30:00Z'\n}\n\n// =============================================================================\n// TESTS DE MIGRATION\n// =============================================================================\n\n/**\n * Teste la conversion d'une facture vers une op√©ration\n */\nexport function testInvoiceToOperation(): { success: boolean; message: string } {\n  try {\n    const operation = invoiceToOperation(sampleInvoice)\n    \n    // V√©rifications\n    const checks = [\n      { test: operation.sens === 'vente', message: 'Sens doit √™tre \"vente\"' },\n      { test: operation.amount_ht_cents === sampleInvoice.amount_ht_cents, message: 'Montant HT conserv√©' },\n      { test: operation.amount_ttc_cents === sampleInvoice.amount_ttc_cents, message: 'Montant TTC conserv√©' },\n      { test: operation.tva_rate === sampleInvoice.tva_rate, message: 'Taux TVA conserv√©' },\n      { test: operation.client_supplier === sampleInvoice.client, message: 'Client conserv√©' },\n      { test: operation.tva_sur_encaissements === sampleInvoice.is_service, message: 'TVA sur encaissements mapp√©e' },\n      { test: operation.encaissement_date === sampleInvoice.payment_date, message: 'Date encaissement mapp√©e' },\n      { test: operation.reference === sampleInvoice.number, message: 'R√©f√©rence mapp√©e' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Migration facture ‚Üí op√©ration r√©ussie' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur migration facture: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste la conversion d'une d√©pense vers une op√©ration\n */\nexport function testExpenseToOperation(): { success: boolean; message: string } {\n  try {\n    const operation = expenseToOperation(sampleExpense)\n    \n    // V√©rifications\n    const checks = [\n      { test: operation.sens === 'achat', message: 'Sens doit √™tre \"achat\"' },\n      { test: operation.amount_ht_cents === sampleExpense.amount_ht_cents, message: 'Montant HT conserv√©' },\n      { test: operation.amount_ttc_cents === sampleExpense.amount_ttc_cents, message: 'Montant TTC conserv√©' },\n      { test: operation.tva_rate === sampleExpense.tva_rate, message: 'Taux TVA conserv√©' },\n      { test: operation.client_supplier === sampleExpense.supplier, message: 'Fournisseur conserv√©' },\n      { test: operation.category === sampleExpense.category, message: 'Cat√©gorie conserv√©e' },\n      { test: operation.tva_sur_encaissements === false, message: 'TVA achats toujours √† la facturation' },\n      { test: operation.status === 'paid', message: 'D√©penses consid√©r√©es comme pay√©es' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Migration d√©pense ‚Üí op√©ration r√©ussie' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur migration d√©pense: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste la migration compl√®te d'une p√©riode\n */\nexport function testPeriodMigration(): { success: boolean; message: string } {\n  try {\n    const invoices = [sampleInvoice]\n    const expenses = [sampleExpense]\n    \n    const operations = migratePeriodToOperations(invoices, expenses)\n    \n    // V√©rifications\n    const checks = [\n      { test: operations.length === 2, message: 'Nombre total d\\'op√©rations correct' },\n      { test: operations.filter(op => op.sens === 'vente').length === 1, message: 'Une vente migr√©e' },\n      { test: operations.filter(op => op.sens === 'achat').length === 1, message: 'Un achat migr√©' },\n      { test: operations.every(op => op.id && op.created_at), message: 'Toutes les op√©rations ont un ID et date cr√©ation' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Migration p√©riode compl√®te r√©ussie' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur migration p√©riode: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n// =============================================================================\n// TESTS DE CALCUL\n// =============================================================================\n\n/**\n * Teste les calculs automatiques de montants\n */\nexport function testCalculateAmounts(): { success: boolean; message: string } {\n  try {\n    const amountHt = 100000 // 1000‚Ç¨\n    const tvaRate = 20 // 20%\n    \n    const result = calculateOperationAmounts(amountHt, tvaRate)\n    \n    const expectedTva = 20000 // 200‚Ç¨\n    const expectedTtc = 120000 // 1200‚Ç¨\n    \n    const checks = [\n      { test: result.amount_ht_cents === amountHt, message: 'HT conserv√©' },\n      { test: result.tva_cents === expectedTva, message: 'TVA calcul√©e correctement' },\n      { test: result.amount_ttc_cents === expectedTtc, message: 'TTC calcul√© correctement' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Calculs automatiques corrects' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs calculs: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur calculs: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste la validation d'op√©ration\n */\nexport function testValidateOperation(): { success: boolean; message: string } {\n  try {\n    // Op√©ration valide\n    const validOperation: Partial<Operation> = {\n      label: 'Test op√©ration',\n      sens: 'vente',\n      amount_ht_cents: 100000,\n      tva_rate: 20,\n      date: '2025-08-01'\n    }\n    \n    const validErrors = validateOperation(validOperation)\n    \n    // Op√©ration invalide\n    const invalidOperation: Partial<Operation> = {\n      label: '', // Manquant\n      sens: 'vente',\n      amount_ht_cents: -1000, // N√©gatif\n      tva_rate: 50, // Trop √©lev√©\n      date: '2025-08-01',\n      tva_sur_encaissements: true // Mais pas de date d'encaissement\n    }\n    \n    const invalidErrors = validateOperation(invalidOperation)\n    \n    const checks = [\n      { test: validErrors.length === 0, message: 'Op√©ration valide ne g√©n√®re pas d\\'erreurs' },\n      { test: invalidErrors.length > 0, message: 'Op√©ration invalide g√©n√®re des erreurs' },\n      { test: invalidErrors.some(e => e.includes('libell√©')), message: 'D√©tecte libell√© manquant' },\n      { test: invalidErrors.some(e => e.includes('montant')), message: 'D√©tecte montant invalide' },\n      { test: invalidErrors.some(e => e.includes('TVA')), message: 'D√©tecte taux TVA invalide' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Validation d\\'op√©ration fonctionne' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs validation: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur validation: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n// =============================================================================\n// TESTS DE CALCUL TVA\n// =============================================================================\n\n/**\n * Teste les nouveaux calculs TVA\n */\nexport function testVatCalculations(): { success: boolean; message: string } {\n  try {\n    const operations = migratePeriodToOperations([sampleInvoice], [sampleExpense])\n    const period = '2025-08'\n    \n    const vatCalc = calculateVatForOperations(period, operations)\n    \n    // V√©rifications attendues :\n    // - TVA collect√©e : 100000 centimes (1000‚Ç¨) car la facture a √©t√© encaiss√©e en ao√ªt\n    // - TVA d√©ductible : 30000 centimes (300‚Ç¨) car la d√©pense a √©t√© faite en ao√ªt\n    // - TVA due : 70000 centimes (700‚Ç¨)\n    \n    const checks = [\n      { test: vatCalc.period === period, message: 'P√©riode correcte' },\n      { test: vatCalc.collected_vat_cents === 100000, message: 'TVA collect√©e calcul√©e' },\n      { test: vatCalc.deductible_vat_cents === 30000, message: 'TVA d√©ductible calcul√©e' },\n      { test: vatCalc.vat_due_cents === 70000, message: 'TVA due calcul√©e' },\n      { test: vatCalc.operations_breakdown.length === 2, message: 'Breakdown des op√©rations' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Calculs TVA nouveaux corrects' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs TVA: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur calculs TVA: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n/**\n * Teste les calculs URSSAF\n */\nexport function testUrssafCalculations(): { success: boolean; message: string } {\n  try {\n    const operations = migratePeriodToOperations([sampleInvoice], [sampleExpense])\n    const period = '2025-08'\n    const urssafRate = 22 // 22%\n    \n    const urssafCalc = calculateUrssafForOperations(period, operations, urssafRate)\n    \n    // V√©rifications attendues :\n    // - Revenu HT : 500000 centimes (5000‚Ç¨) - uniquement les ventes\n    // - URSSAF due : 110000 centimes (1100‚Ç¨) = 5000‚Ç¨ * 22%\n    \n    const checks = [\n      { test: urssafCalc.period === period, message: 'P√©riode correcte' },\n      { test: urssafCalc.revenue_ht_cents === 500000, message: 'Revenu HT calcul√©' },\n      { test: urssafCalc.urssaf_due_cents === 110000, message: 'URSSAF due calcul√©e' },\n      { test: urssafCalc.urssaf_rate === urssafRate, message: 'Taux URSSAF correct' }\n    ]\n    \n    const failedChecks = checks.filter(check => !check.test)\n    \n    if (failedChecks.length === 0) {\n      return { success: true, message: 'Calculs URSSAF nouveaux corrects' }\n    } else {\n      return { \n        success: false, \n        message: `√âchecs URSSAF: ${failedChecks.map(c => c.message).join(', ')}` \n      }\n    }\n  } catch (error) {\n    return { \n      success: false, \n      message: `Erreur calculs URSSAF: ${error instanceof Error ? error.message : error}` \n    }\n  }\n}\n\n// =============================================================================\n// SUITE DE TESTS COMPL√àTE\n// =============================================================================\n\n/**\n * Ex√©cute tous les tests de migration\n */\nexport function runAllMigrationTests(): {\n  success: boolean\n  results: Array<{ test: string; success: boolean; message: string }>\n  summary: string\n} {\n  const tests = [\n    { name: 'Migration Facture ‚Üí Op√©ration', test: testInvoiceToOperation },\n    { name: 'Migration D√©pense ‚Üí Op√©ration', test: testExpenseToOperation },\n    { name: 'Migration P√©riode Compl√®te', test: testPeriodMigration },\n    { name: 'Calculs Automatiques', test: testCalculateAmounts },\n    { name: 'Validation Op√©ration', test: testValidateOperation },\n    { name: 'Nouveaux Calculs TVA', test: testVatCalculations },\n    { name: 'Nouveaux Calculs URSSAF', test: testUrssafCalculations }\n  ]\n  \n  const results = tests.map(({ name, test }) => ({\n    test: name,\n    ...test()\n  }))\n  \n  const successCount = results.filter(r => r.success).length\n  const totalCount = results.length\n  const overallSuccess = successCount === totalCount\n  \n  const summary = `Tests Migration: ${successCount}/${totalCount} r√©ussis. ${overallSuccess ? '‚úÖ SUCC√àS' : '‚ùå √âCHECS'}`\n  \n  return {\n    success: overallSuccess,\n    results,\n    summary\n  }\n}\n\n/**\n * Utilitaire pour logger les r√©sultats des tests\n */\nexport function logTestResults(): void {\n  console.log('üß™ === TESTS MIGRATION MOD√àLE OPERATION UNIFI√â ===')\n  \n  const { success, results, summary } = runAllMigrationTests()\n  \n  console.log(`\\nüìä ${summary}\\n`)\n  \n  results.forEach(result => {\n    const icon = result.success ? '‚úÖ' : '‚ùå'\n    console.log(`${icon} ${result.test}: ${result.message}`)\n  })\n  \n  if (success) {\n    console.log('\\nüéâ Tous les tests passent ! La migration est pr√™te.')\n  } else {\n    console.log('\\n‚ö†Ô∏è  Certains tests √©chouent. V√©rifier avant d√©ploiement.')\n  }\n  \n  console.log('\\n=== FIN TESTS ===')\n}